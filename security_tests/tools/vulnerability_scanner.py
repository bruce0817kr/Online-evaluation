#!/usr/bin/env python3
"""
AI 모델 관리 시스템 - 취약점 스캐너
자동화된 보안 취약점 검사 도구
"""

import os
import re
import json
import subprocess
import asyncio
import aiohttp
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging
from datetime import datetime
import yaml

@dataclass
class VulnerabilityFinding:
    """취약점 발견사항"""
    vuln_id: str
    title: str
    severity: str  # critical, high, medium, low, info
    cwe_id: Optional[str]
    description: str
    location: str
    evidence: Dict
    remediation: str
    references: List[str]

class VulnerabilityScanner:
    """취약점 스캐너 클래스"""
    
    def __init__(self, config_file: str = "security_tests/config/security_test_config.yml"):
        self.config = self._load_config(config_file)
        self.findings: List[VulnerabilityFinding] = []
        
        # 로깅 설정
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
    def _load_config(self, config_file: str) -> Dict:
        """설정 파일 로드"""
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            self.logger.warning(f"설정 파일을 찾을 수 없음: {config_file}")
            return self._get_default_config()
            
    def _get_default_config(self) -> Dict:
        """기본 설정 반환"""
        return {
            'data_security_tests': {
                'enabled': True,
                'sensitive_data_patterns': {
                    'api_keys': r'sk-[a-zA-Z0-9]{48}|sk-ant-[a-zA-Z0-9]{95}',
                    'passwords': r'password\s*[:=]\s*["\']([^"\']+)["\']',
                    'tokens': r'token\s*[:=]\s*["\']([^"\']+)["\']',
                    'emails': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
                    'private_keys': r'-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----'
                },
                'check_locations': ['backend/', 'frontend/src/', 'logs/', '.env*']
            },
            'vulnerability_scanning': {
                'enabled': True,
                'tools': {
                    'bandit': {'enabled': True, 'target': 'backend/'},
                    'safety': {'enabled': True, 'target': 'requirements.txt'},
                    'custom_scanner': {'enabled': True}
                }
            }
        }
        
    async def scan_all(self) -> List[VulnerabilityFinding]:
        """전체 취약점 스캔 실행"""
        self.logger.info("취약점 스캔 시작")
        
        # 1. 민감 정보 스캔
        if self.config.get('data_security_tests', {}).get('enabled', True):
            await self._scan_sensitive_data()
            
        # 2. 정적 코드 분석
        if self.config.get('vulnerability_scanning', {}).get('enabled', True):
            await self._run_static_analysis()
            
        # 3. 의존성 취약점 검사
        await self._scan_dependencies()
        
        # 4. 설정 파일 보안 검사
        await self._scan_configuration_files()
        
        # 5. 웹 취약점 스캔
        await self._scan_web_vulnerabilities()
        
        self.logger.info(f"취약점 스캔 완료: {len(self.findings)}개 발견")
        return self.findings
        
    async def _scan_sensitive_data(self):
        """민감 정보 스캔"""
        self.logger.info("민감 정보 스캔 중...")
        
        patterns = self.config.get('data_security_tests', {}).get('sensitive_data_patterns', {})
        locations = self.config.get('data_security_tests', {}).get('check_locations', [])
        
        for location in locations:
            if os.path.exists(location):
                await self._scan_directory_for_patterns(location, patterns)
                
    async def _scan_directory_for_patterns(self, directory: str, patterns: Dict[str, str]):
        """디렉터리에서 패턴 검색"""
        for root, dirs, files in os.walk(directory):
            # .git, node_modules 등 제외
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != 'node_modules']
            
            for file in files:
                if file.startswith('.') and not file.endswith(('.env', '.env.example')):
                    continue
                    
                file_path = os.path.join(root, file)
                await self._scan_file_for_patterns(file_path, patterns)
                
    async def _scan_file_for_patterns(self, file_path: str, patterns: Dict[str, str]):
        """파일에서 민감 정보 패턴 검색"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            for pattern_name, pattern in patterns.items():
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                
                for match in matches:
                    # 실제 민감 정보인지 검증
                    if self._is_real_sensitive_data(pattern_name, match.group()):
                        finding = VulnerabilityFinding(
                            vuln_id=f"SENSITIVE_{pattern_name.upper()}_{len(self.findings)+1}",
                            title=f"민감 정보 노출: {pattern_name}",
                            severity="high" if pattern_name in ['api_keys', 'private_keys'] else "medium",
                            cwe_id="CWE-200",
                            description=f"파일에서 {pattern_name} 패턴이 발견되었습니다",
                            location=f"{file_path}:{self._get_line_number(content, match.start())}",
                            evidence={\n                                "file": file_path,\n                                "pattern": pattern_name,\n                                "match": match.group()[:50] + "..." if len(match.group()) > 50 else match.group(),\n                                "line": self._get_line_number(content, match.start())\n                            },\n                            remediation=self._get_remediation_for_pattern(pattern_name),\n                            references=["https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"]\n                        )\n                        self.findings.append(finding)\n                        \n        except Exception as e:\n            self.logger.warning(f"파일 스캔 실패: {file_path} - {e}")\n            \n    def _is_real_sensitive_data(self, pattern_name: str, match: str) -> bool:\n        """실제 민감 정보인지 검증"""\n        # 테스트 데이터나 예제 데이터 제외\n        test_indicators = ['test', 'example', 'demo', 'fake', 'mock', 'placeholder']\n        \n        if any(indicator in match.lower() for indicator in test_indicators):\n            return False\n            \n        # 패턴별 추가 검증\n        if pattern_name == 'api_keys':\n            return not (match.startswith('sk-test') or 'example' in match)\n        elif pattern_name == 'passwords':\n            return len(match) > 8 and not any(weak in match.lower() for weak in ['test', 'admin', '123'])\n            \n        return True\n        \n    def _get_line_number(self, content: str, position: int) -> int:\n        """문자 위치에서 라인 번호 계산"""\n        return content[:position].count('\\n') + 1\n        \n    def _get_remediation_for_pattern(self, pattern_name: str) -> str:\n        """패턴별 수정 권장사항"""\n        remediation_map = {\n            'api_keys': "API 키를 환경 변수로 이동하고 .env 파일을 .gitignore에 추가하세요",\n            'passwords': "비밀번호를 하드코딩하지 말고 환경 변수나 보안 설정 파일을 사용하세요",\n            'tokens': "토큰을 환경 변수로 관리하고 코드에서 제거하세요",\n            'private_keys': "개인 키를 안전한 키 관리 시스템으로 이동하세요",\n            'emails': "이메일 주소가 실제 사용자 데이터인 경우 제거하거나 마스킹하세요"\n        }\n        return remediation_map.get(pattern_name, "민감 정보를 코드에서 제거하고 안전한 방법으로 관리하세요")\n        \n    async def _run_static_analysis(self):\n        """정적 코드 분석 실행"""\n        tools = self.config.get('vulnerability_scanning', {}).get('tools', {})\n        \n        # Bandit 실행\n        if tools.get('bandit', {}).get('enabled', True):\n            await self._run_bandit(tools['bandit'].get('target', 'backend/'))\n            \n        # 커스텀 스캐너 실행\n        if tools.get('custom_scanner', {}).get('enabled', True):\n            await self._run_custom_scanner()\n            \n    async def _run_bandit(self, target_dir: str):\n        """Bandit 정적 분석 실행"""\n        if not os.path.exists(target_dir):\n            return\n            \n        try:\n            result = subprocess.run(\n                ['bandit', '-r', target_dir, '-f', 'json'],\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n            \n            if result.stdout:\n                bandit_results = json.loads(result.stdout)\n                self._process_bandit_results(bandit_results)\n                \n        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError) as e:\n            self.logger.warning(f"Bandit 실행 실패: {e}")\n            \n    def _process_bandit_results(self, results: Dict):\n        """Bandit 결과 처리"""\n        for issue in results.get('results', []):\n            severity_map = {\n                'HIGH': 'high',\n                'MEDIUM': 'medium', \n                'LOW': 'low'\n            }\n            \n            finding = VulnerabilityFinding(\n                vuln_id=f"BANDIT_{issue.get('test_id', 'UNKNOWN')}_{len(self.findings)+1}",\n                title=issue.get('test_name', 'Bandit Security Issue'),\n                severity=severity_map.get(issue.get('issue_severity', 'MEDIUM'), 'medium'),\n                cwe_id=issue.get('issue_cwe', {}).get('id'),\n                description=issue.get('issue_text', ''),\n                location=f"{issue.get('filename', '')}:{issue.get('line_number', 0)}",\n                evidence={\n                    "code": issue.get('code', ''),\n                    "confidence": issue.get('issue_confidence', ''),\n                    "line_range": issue.get('line_range', [])\n                },\n                remediation="Bandit에서 식별된 보안 문제를 검토하고 수정하세요",\n                references=[issue.get('more_info', '')]\n            )\n            self.findings.append(finding)\n            \n    async def _run_custom_scanner(self):\n        """커스텀 보안 스캐너 실행"""\n        # 하드코딩된 보안 취약점 패턴 검사\n        security_patterns = {\n            'debug_mode': r'DEBUG\\s*=\\s*True',\n            'sql_injection': r'(SELECT|INSERT|UPDATE|DELETE).*%s',\n            'weak_crypto': r'(MD5|SHA1)\\(',\n            'unsafe_eval': r'eval\\s*\\(',\n            'unsafe_exec': r'exec\\s*\\(',\n            'shell_injection': r'os\\.system\\s*\\(',\n            'unsafe_pickle': r'pickle\\.loads?\\s*\\(',\n            'unsafe_yaml': r'yaml\\.load\\s*\\('\n        }\n        \n        for root, dirs, files in os.walk('.'):\n            dirs[:] = [d for d in dirs if not d.startswith('.') and d != 'node_modules']\n            \n            for file in files:\n                if file.endswith(('.py', '.js', '.ts', '.jsx', '.tsx')):\n                    file_path = os.path.join(root, file)\n                    await self._scan_file_for_security_patterns(file_path, security_patterns)\n                    \n    async def _scan_file_for_security_patterns(self, file_path: str, patterns: Dict[str, str]):\n        """파일에서 보안 패턴 검색"""\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                \n            for pattern_name, pattern in patterns.items():\n                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)\n                \n                for match in matches:\n                    finding = VulnerabilityFinding(\n                        vuln_id=f"CUSTOM_{pattern_name.upper()}_{len(self.findings)+1}",\n                        title=f"보안 취약점: {pattern_name}",\n                        severity=self._get_severity_for_pattern(pattern_name),\n                        cwe_id=self._get_cwe_for_pattern(pattern_name),\n                        description=f"잠재적 보안 취약점 패턴이 발견되었습니다: {pattern_name}",\n                        location=f"{file_path}:{self._get_line_number(content, match.start())}",\n                        evidence={\n                            "pattern": pattern_name,\n                            "match": match.group(),\n                            "line": self._get_line_number(content, match.start())\n                        },\n                        remediation=self._get_custom_remediation(pattern_name),\n                        references=["https://owasp.org/www-project-top-ten/"]\n                    )\n                    self.findings.append(finding)\n                    \n        except Exception as e:\n            self.logger.warning(f"커스텀 스캔 실패: {file_path} - {e}")\n            \n    def _get_severity_for_pattern(self, pattern_name: str) -> str:\n        \"\"\"패턴별 심각도 반환\"\"\"\n        severity_map = {\n            'debug_mode': 'medium',\n            'sql_injection': 'high',\n            'weak_crypto': 'medium',\n            'unsafe_eval': 'high',\n            'unsafe_exec': 'critical',\n            'shell_injection': 'critical',\n            'unsafe_pickle': 'high',\n            'unsafe_yaml': 'high'\n        }\n        return severity_map.get(pattern_name, 'medium')\n        \n    def _get_cwe_for_pattern(self, pattern_name: str) -> str:\n        \"\"\"패턴별 CWE ID 반환\"\"\"\n        cwe_map = {\n            'debug_mode': 'CWE-489',\n            'sql_injection': 'CWE-89',\n            'weak_crypto': 'CWE-327',\n            'unsafe_eval': 'CWE-95',\n            'unsafe_exec': 'CWE-95',\n            'shell_injection': 'CWE-78',\n            'unsafe_pickle': 'CWE-502',\n            'unsafe_yaml': 'CWE-502'\n        }\n        return cwe_map.get(pattern_name)\n        \n    def _get_custom_remediation(self, pattern_name: str) -> str:\n        \"\"\"패턴별 수정 권장사항\"\"\"\n        remediation_map = {\n            'debug_mode': "프로덕션 환경에서는 DEBUG=False로 설정하세요",\n            'sql_injection': "매개변수화된 쿼리나 ORM을 사용하세요",\n            'weak_crypto': "SHA-256 이상의 강력한 해시 알고리즘을 사용하세요",\n            'unsafe_eval': "eval() 함수 사용을 피하고 안전한 대안을 사용하세요",\n            'unsafe_exec': "exec() 함수 사용을 피하고 안전한 대안을 사용하세요",\n            'shell_injection': "subprocess.run()과 적절한 인수 전달을 사용하세요",\n            'unsafe_pickle': "JSON이나 다른 안전한 직렬화 방법을 사용하세요",\n            'unsafe_yaml': "yaml.safe_load()를 사용하세요"\n        }\n        return remediation_map.get(pattern_name, "보안 취약점을 검토하고 수정하세요")\n        \n    async def _scan_dependencies(self):\n        \"\"\"의존성 취약점 검사\"\"\"\n        # Python 의존성 검사\n        if os.path.exists('requirements.txt'):\n            await self._scan_python_dependencies()\n            \n        # Node.js 의존성 검사\n        if os.path.exists('package.json'):\n            await self._scan_nodejs_dependencies()\n            \n    async def _scan_python_dependencies(self):\n        \"\"\"Python 의존성 취약점 검사\"\"\"\n        try:\n            result = subprocess.run(\n                ['safety', 'check', '--json'],\n                capture_output=True,\n                text=True,\n                timeout=60\n            )\n            \n            if result.stdout:\n                safety_results = json.loads(result.stdout)\n                self._process_safety_results(safety_results)\n                \n        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError) as e:\n            self.logger.warning(f"Safety 실행 실패: {e}")\n            \n    def _process_safety_results(self, results: List[Dict]):\n        \"\"\"Safety 결과 처리\"\"\"\n        for vuln in results:\n            finding = VulnerabilityFinding(\n                vuln_id=f"SAFETY_{vuln.get('id', 'UNKNOWN')}",\n                title=f"의존성 취약점: {vuln.get('package_name', 'Unknown')}",\n                severity=self._map_safety_severity(vuln.get('severity', 'medium')),\n                cwe_id=None,\n                description=vuln.get('advisory', ''),\n                location=f"requirements.txt:{vuln.get('package_name', '')}",\n                evidence={\n                    "package": vuln.get('package_name', ''),\n                    "installed_version": vuln.get('installed_version', ''),\n                    "affected_versions": vuln.get('affected_versions', ''),\n                    "safe_versions": vuln.get('safe_versions', [])\n                },\n                remediation=f"패키지를 안전한 버전으로 업데이트하세요: {vuln.get('safe_versions', [])}",\n                references=[vuln.get('more_info_url', '')]\n            )\n            self.findings.append(finding)\n            \n    def _map_safety_severity(self, severity: str) -> str:\n        \"\"\"Safety 심각도 매핑\"\"\"\n        severity_map = {\n            'critical': 'critical',\n            'high': 'high',\n            'medium': 'medium',\n            'low': 'low'\n        }\n        return severity_map.get(severity.lower(), 'medium')\n        \n    async def _scan_nodejs_dependencies(self):\n        \"\"\"Node.js 의존성 취약점 검사\"\"\"\n        try:\n            result = subprocess.run(\n                ['npm', 'audit', '--json'],\n                capture_output=True,\n                text=True,\n                timeout=60\n            )\n            \n            if result.stdout:\n                audit_results = json.loads(result.stdout)\n                self._process_npm_audit_results(audit_results)\n                \n        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError) as e:\n            self.logger.warning(f"npm audit 실행 실패: {e}")\n            \n    def _process_npm_audit_results(self, results: Dict):\n        \"\"\"npm audit 결과 처리\"\"\"\n        vulnerabilities = results.get('vulnerabilities', {})\n        \n        for package_name, vuln_data in vulnerabilities.items():\n            finding = VulnerabilityFinding(\n                vuln_id=f"NPM_{package_name}_{len(self.findings)+1}",\n                title=f"Node.js 의존성 취약점: {package_name}",\n                severity=vuln_data.get('severity', 'medium'),\n                cwe_id=None,\n                description=vuln_data.get('title', ''),\n                location=f"package.json:{package_name}",\n                evidence={\n                    "package": package_name,\n                    "range": vuln_data.get('range', ''),\n                    "via": vuln_data.get('via', []),\n                    "effects": vuln_data.get('effects', [])\n                },\n                remediation="npm update 또는 npm audit fix를 실행하여 취약점을 수정하세요",\n                references=vuln_data.get('url', [])\n            )\n            self.findings.append(finding)\n            \n    async def _scan_configuration_files(self):\n        \"\"\"설정 파일 보안 검사\"\"\"\n        config_files = [\n            '.env', '.env.local', '.env.production',\n            'config.py', 'settings.py', 'config.json',\n            'docker-compose.yml', 'Dockerfile'\n        ]\n        \n        for config_file in config_files:\n            if os.path.exists(config_file):\n                await self._scan_config_file(config_file)\n                \n    async def _scan_config_file(self, file_path: str):\n        \"\"\"개별 설정 파일 검사\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                \n            # 설정 파일별 보안 검사 패턴\n            if file_path.endswith('.env'):\n                await self._check_env_file_security(file_path, content)\n            elif 'docker' in file_path.lower():\n                await self._check_docker_security(file_path, content)\n                \n        except Exception as e:\n            self.logger.warning(f"설정 파일 스캔 실패: {file_path} - {e}")\n            \n    async def _check_env_file_security(self, file_path: str, content: str):\n        \"\"\"환경 설정 파일 보안 검사\"\"\"\n        # 기본 비밀번호 검사\n        weak_patterns = [\n            r'PASSWORD\\s*=\\s*["\']?(admin|password|123456|test)["\']?',\n            r'SECRET\\s*=\\s*["\']?(secret|test|dev)["\']?',\n            r'API_KEY\\s*=\\s*["\']?(test|demo|example)["\']?'\n        ]\n        \n        for pattern in weak_patterns:\n            matches = re.finditer(pattern, content, re.IGNORECASE)\n            for match in matches:\n                finding = VulnerabilityFinding(\n                    vuln_id=f"WEAK_CONFIG_{len(self.findings)+1}",\n                    title="약한 설정값",\n                    severity="medium",\n                    cwe_id="CWE-521",\n                    description="설정 파일에 약한 비밀번호나 기본값이 사용되고 있습니다",\n                    location=f"{file_path}:{self._get_line_number(content, match.start())}",\n                    evidence={"match": match.group()},\n                    remediation="강력한 비밀번호와 무작위 시크릿 키를 사용하세요",\n                    references=["https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication"]\n                )\n                self.findings.append(finding)\n                \n    async def _check_docker_security(self, file_path: str, content: str):\n        \"\"\"Docker 설정 보안 검사\"\"\"\n        # Docker 보안 패턴 검사\n        security_issues = [\n            (r'USER\\s+root', "Root 사용자 사용", "medium"),\n            (r'--privileged', "특권 모드 사용", "high"),\n            (r'COPY\\s+\\.\\s+/', "전체 디렉터리 복사", "low"),\n            (r'RUN\\s+.*sudo', "sudo 사용", "medium")\n        ]\n        \n        for pattern, title, severity in security_issues:\n            matches = re.finditer(pattern, content, re.IGNORECASE)\n            for match in matches:\n                finding = VulnerabilityFinding(\n                    vuln_id=f"DOCKER_SECURITY_{len(self.findings)+1}",\n                    title=f"Docker 보안 문제: {title}",\n                    severity=severity,\n                    cwe_id="CWE-250",\n                    description=f"Docker 설정에서 보안 문제가 발견되었습니다: {title}",\n                    location=f"{file_path}:{self._get_line_number(content, match.start())}",\n                    evidence={"match": match.group()},\n                    remediation="Docker 보안 모범 사례를 따르세요",\n                    references=["https://docs.docker.com/develop/security-best-practices/"]\n                )\n                self.findings.append(finding)\n                \n    async def _scan_web_vulnerabilities(self):\n        \"\"\"웹 취약점 스캔\"\"\"\n        # 간단한 웹 취약점 검사 (헤더 검사 등)\n        target_url = self.config.get('target', {}).get('frontend_url')\n        if not target_url:\n            return\n            \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(target_url) as response:\n                    await self._check_security_headers(response)\n                    \n        except Exception as e:\n            self.logger.warning(f"웹 취약점 스캔 실패: {e}")\n            \n    async def _check_security_headers(self, response):\n        \"\"\"보안 헤더 검사\"\"\"\n        required_headers = {\n            'X-Content-Type-Options': 'nosniff',\n            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],\n            'X-XSS-Protection': '1; mode=block',\n            'Strict-Transport-Security': None,\n            'Content-Security-Policy': None\n        }\n        \n        for header, expected_value in required_headers.items():\n            if header not in response.headers:\n                finding = VulnerabilityFinding(\n                    vuln_id=f"MISSING_HEADER_{header}",\n                    title=f"보안 헤더 누락: {header}",\n                    severity="medium",\n                    cwe_id="CWE-693",\n                    description=f"중요한 보안 헤더가 누락되었습니다: {header}",\n                    location="HTTP Response Headers",\n                    evidence={"missing_header": header},\n                    remediation=f"응답에 {header} 헤더를 추가하세요",\n                    references=["https://owasp.org/www-project-secure-headers/"]\n                )\n                self.findings.append(finding)\n                \n    def generate_report(self) -> Dict:\n        \"\"\"취약점 스캔 리포트 생성\"\"\"\n        # 심각도별 통계\n        severity_counts = {}\n        for finding in self.findings:\n            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1\n            \n        # CWE별 통계\n        cwe_counts = {}\n        for finding in self.findings:\n            if finding.cwe_id:\n                cwe_counts[finding.cwe_id] = cwe_counts.get(finding.cwe_id, 0) + 1\n                \n        report = {\n            'scan_info': {\n                'timestamp': datetime.now().isoformat(),\n                'total_findings': len(self.findings),\n                'severity_distribution': severity_counts,\n                'cwe_distribution': cwe_counts\n            },\n            'findings': [\n                {\n                    'vuln_id': f.vuln_id,\n                    'title': f.title,\n                    'severity': f.severity,\n                    'cwe_id': f.cwe_id,\n                    'description': f.description,\n                    'location': f.location,\n                    'evidence': f.evidence,\n                    'remediation': f.remediation,\n                    'references': f.references\n                }\n                for f in sorted(self.findings, key=lambda x: {'critical': 4, 'high': 3, 'medium': 2, 'low': 1, 'info': 0}.get(x.severity, 0), reverse=True)\n            ]\n        }\n        \n        return report\n        \n    def save_report(self, report: Dict, filename: str = None):\n        \"\"\"리포트 저장\"\"\"\n        if not filename:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"vulnerability_scan_report_{timestamp}.json\"\n            \n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(report, f, indent=2, ensure_ascii=False)\n            \n        self.logger.info(f"취약점 스캔 리포트 저장: {filename}\")\n\nasync def main():\n    \"\"\"메인 함수\"\"\"\n    scanner = VulnerabilityScanner()\n    \n    # 취약점 스캔 실행\n    await scanner.scan_all()\n    \n    # 리포트 생성 및 저장\n    report = scanner.generate_report()\n    scanner.save_report(report)\n    \n    # 요약 출력\n    print(f\"\\n=== 취약점 스캔 완료 ===\")\n    print(f\"총 발견된 취약점: {len(scanner.findings)}개\")\n    \n    severity_counts = report['scan_info']['severity_distribution']\n    for severity in ['critical', 'high', 'medium', 'low', 'info']:\n        count = severity_counts.get(severity, 0)\n        if count > 0:\n            print(f\"{severity.upper()}: {count}개\")\n            \nif __name__ == \"__main__\":\n    asyncio.run(main())